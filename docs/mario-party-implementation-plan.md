# Mario Party Style Game Implementation Plan (v0.1)

## 1) Requirement intake and assumptions

Because there is no connected Notion MCP resource in this workspace, this plan is based on the user request only:

- Build a game inspired by Mario Party
- Start from implementation strategy and system design

Working assumptions for this first draft:

- Platform: PC first (Windows), gamepad + keyboard support
- Session size: 2-4 players
- Mode priority: online play first, local play later
- Scope priority: "playable MVP quickly" over "many polished contents"

## 2) Product goals

1. Deliver a fun, replayable board + minigame loop.
2. Keep each match short enough to stream/share (20-35 minutes).
3. Make comeback mechanics meaningful so the winner is not obvious early.
4. Build a content pipeline where new boards/minigames can be added without core rewrites.

## 3) Design pillars

- **Easy to start**: low onboarding friction, clear turn UI.
- **Strategic chaos**: player agency with controlled randomness.
- **Fast cadence**: minimal downtime between turns and minigames.
- **Fair outcomes**: server-validated results for online trust.

## 4) Core gameplay loop (MVP)

1. Players join lobby and pick character.
2. Match starts with selected board, fixed number of turns.
3. On each turn:
   - Roll dice
   - Move on board graph
   - Trigger tile event
   - Optional item usage
4. After all players act, launch minigame.
5. Award coins/stars, update ranking.
6. Repeat until final turn.
7. Endgame bonus awards + winner presentation.

## 5) MVP scope definition

## In scope (must-have)

- 1 board (about 20-30 nodes, branching paths)
- Turn engine (movement, coins, stars, tile effects)
- 6-8 minigames:
  - 4-player free-for-all (at least 3)
  - 2v2 team (at least 2)
  - 1v3 asymmetric (at least 1)
- Item system (3-5 items)
- Match settings:
  - 10 / 15 / 20 turns
  - human + bot fill
- Basic progression:
  - profile level
  - cosmetic unlock placeholders
- Reconnect support for temporary network drop

## Out of scope (post-MVP)

- Full single-player campaign
- Cross-platform release (console/mobile)
- UGC map editor
- Battle pass / shop economy
- Voice chat

## 6) Recommended technical stack (initial)

- **Engine**: Unity 6 (C#)
- **Networking (MVP)**: Unity Netcode for GameObjects + Unity Lobby/Relay
- **Backend (minimal)**:
  - authentication + player profile storage
  - match result ingestion
  - telemetry aggregation
- **Data storage**:
  - static configs in JSON/ScriptableObjects
  - player data in managed backend DB

Why this stack for v0.1:

- Fast prototype speed for board + minigame flow
- Sufficient ecosystem for multiplayer basics
- Clear migration path from host-authoritative MVP to dedicated server architecture

## 7) Network and authority model

### MVP model

- Host-authoritative simulation
- Server RPC validation for critical actions:
  - dice result seed usage
  - item activation legality
  - star purchase checks
  - minigame result submission

### Anti-cheat baseline

- Deterministic RNG seeds generated by host and signed by match nonce
- Client sends intent, host applies final state transition
- End-of-match event log checksum uploaded for anomaly review

### Dedicated-server migration (Phase 2)

- Move board state simulation to dedicated authoritative process
- Keep minigame result channel compatible with same event contract

## 8) Game system architecture

## Client modules

- `LobbyModule`: room create/join/readiness
- `BoardModule`: turn flow, movement, tile events
- `MinigameModule`: scene loading, rules adapter
- `UIShell`: HUD, ranking, notifications
- `ProgressionModule`: profile, rewards, unlocks

## Shared domain modules

- `RuleEngine`: deterministic turn and tile resolution
- `EconomyRules`: coin/star/item operations
- `EventBus`: typed gameplay events for UI + telemetry

## Backend modules

- `ProfileService`: account and progression state
- `MatchService`: create match record and final result
- `TelemetryService`: ingest gameplay analytics events

## 9) Data model (first pass)

Core entities:

- `PlayerState`
  - playerId
  - positionNodeId
  - coins
  - stars
  - inventory[]
  - isBot
- `MatchState`
  - matchId
  - boardId
  - turnIndex
  - maxTurns
  - currentPlayerId
  - rngSeedBase
- `BoardNode`
  - nodeId
  - nodeType (blue, red, event, shop, star, duel)
  - neighbors[]
- `MinigameDefinition`
  - minigameId
  - mode (4p, 2v2, 1v3)
  - sceneRef
  - rewardRuleId

## 10) Content pipeline plan

- Board rules in data-first format (JSON) to avoid hardcoding.
- Minigames implement a common interface:
  - `Setup(context)`
  - `StartGame()`
  - `SubmitResult(resultPayload)`
  - `Teardown()`
- Add validation script that checks board graph connectivity and dead-ends.

## 11) Delivery plan (sequential implementation)

## Phase 0 - technical spike (1 week)

Goals:

- Confirm deterministic board simulation in network session
- Validate host migration/reconnect behavior

Experiments:

1. Dice + move sync under 120ms simulated latency
2. Mid-turn reconnect restore
3. Minigame transition loading time under 8 seconds

Exit criteria:

- No game-breaking desync in 50 internal matches

Rollback strategy:

- If network desync persists, ship offline/local prototype first and keep online behind feature flag

## Phase 1 - core MVP production (4-6 weeks)

- Build board loop, items, economy
- Build 6-8 minigames with shared adapter
- Add bots and match completion flow
- Add result persistence + analytics events

Exit criteria:

- 2-4 players can finish full match without manual admin intervention

Rollback strategy:

- If minigame count blocks schedule, cut to 4 high-quality minigames for release candidate

## Phase 2 - hardening and beta (2-3 weeks)

- Balance tuning from telemetry
- Connection stability and reconnect QA
- UX polish (turn speed, readability, effects)

Exit criteria:

- Crash-free rate and session completion goals met

Rollback strategy:

- Disable unstable features with remote config (specific items/minigames)

## 12) Test strategy

- Unit tests:
  - turn resolution
  - economy transactions
  - board traversal rules
- Integration tests:
  - lobby to board to minigame transition
  - reconnect and resume
- Soak tests:
  - long-running bot matches for memory/perf
- Balance tests:
  - simulation of 1,000+ bot matches to inspect coin/star distributions

## 13) Key risks and mitigations

1. **Network desync risk**
   - Mitigation: deterministic RuleEngine + authoritative state snapshots
2. **Content production bottleneck (many minigames)**
   - Mitigation: shared minigame framework, strict template, small mechanic set
3. **Low replayability**
   - Mitigation: weighted random events, item counterplay, endgame bonus variety
4. **Scope creep**
   - Mitigation: must-have list frozen during Phase 1

## 14) Immediate next actions (this week)

1. Lock platform and netcode choice.
2. Write formal game rules for turn/economy in a machine-testable format.
3. Build board prototype scene with one complete turn cycle.
4. Implement one minigame using the shared interface.
5. Stand up telemetry event schema before large playtests.
