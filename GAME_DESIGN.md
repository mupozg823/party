# Mario Party 스타일 게임 초기 설계서 (v0.1)

## 1) 목표

플레이어가 보드 위를 이동하고, 턴 단위 이벤트 및 미니게임으로 경쟁하는
**파티 게임 코어 루프**를 우선 구현한다.

- 목표 플랫폼: PC 웹(브라우저) 우선
- 목표 인원: 2~4인
- 모드: 온라인 멀티(우선), 로컬 핫시트(보조)
- 우선순위: "재미 검증 가능한 MVP"를 빠르게 완성

---

## 2) MVP 범위 (처음 6~8주)

### 포함
- 로비/방 생성, 참가, 준비(Ready)
- 1개 보드맵(타일 40~60개)
- 턴 진행(주사위 굴림 -> 이동 -> 타일 이벤트)
- 재화 2종(코인, 스타)
- 미니게임 3종(동일 규칙 반복 가능한 구조)
- 게임 종료 및 순위 산정

### 제외 (MVP 이후)
- 복잡한 캐릭터 스킬 트리
- 20종 이상의 미니게임 대량 콘텐츠
- 시즌 패스/상점/코스메틱
- 리플레이/관전 시스템

---

## 3) 권장 기술 스택

초기 개발 속도와 운영 편의성을 고려해 아래 조합을 권장한다.

### 기본안 (웹 기반)
- 클라이언트: TypeScript + Phaser
- 서버: Node.js + Colyseus (권한형 authoritative 서버)
- 실시간 통신: WebSocket
- 저장소: PostgreSQL (영속 데이터), Redis (매치/세션 캐시)
- 배포: Docker + 단일 클라우드 VM 혹은 컨테이너 플랫폼

### 대안 (고품질 3D 중심)
- Unity + Netcode/Photon 조합
- 장점: 3D 연출/애니메이션 강점
- 단점: 서버 권한 모델/운영 복잡도 상승

---

## 4) 게임 루프 설계

1. 로비 입장
2. 방 생성/참가
3. 준비 완료 후 게임 시작
4. 턴 루프 반복
   - 턴 시작
   - 주사위
   - 이동
   - 타일 효과 처리
   - 턴 종료
5. 라운드 종료 시 미니게임 실행
6. 보상 분배
7. 최종 라운드 종료 후 결과 집계

---

## 5) 시스템 아키텍처 (핵심 원칙)

### 서버 권한형(authoritative)
- 이동, 재화 변경, 스타 구매, 승패 판정은 서버만 확정한다.
- 클라이언트는 입력 요청과 연출(예측/보간)만 담당한다.

### 상태 동기화
- 서버는 "단일 진실 소스(SSOT)"로 게임 상태를 유지
- 클라이언트는 스냅샷/이벤트를 수신하여 UI 반영
- 지연 대응: 입력 락 + 애니메이션 큐 + 상태 버전 번호

### 모듈 경계
- Lobby Service: 방/매치 생성
- Game Service: 턴/보드/경제 로직
- Minigame Service: 미니게임 세션 실행 및 결과 반환
- Progress Service: 프로필, 통계, 메타데이터

---

## 6) 데이터 모델 (초기)

### PlayerState
- playerId
- position
- coins
- stars
- inventoryItems[]
- isDisconnected

### MatchState
- matchId
- round
- currentTurnPlayerId
- turnPhase (ROLL / MOVE / TILE_EVENT / END)
- boardSeed
- players[]
- eventLog[]

### Tile
- tileId
- tileType (COIN_PLUS, COIN_MINUS, SHOP, BRANCH, EVENT, STAR)
- nextTileIds[]
- payload

---

## 7) 미니게임 아키텍처

미니게임을 교체 가능한 플러그인 형태로 설계한다.

- `IMinigame` 인터페이스
  - `init(context)`
  - `start()`
  - `handleInput(playerId, input)`
  - `tick(dt)`
  - `finish(): MinigameResult`

- 공통 보상 규칙은 상위 Game Service가 담당
- 개별 미니게임은 "입력 -> 판정"에 집중

---

## 8) 단계별 구현 계획 (Sequential Plan)

## Phase 0: 기술 검증 (3~5일)
- 목표: 네트워크 지연 상황에서도 턴 동기화가 깨지지 않는지 검증
- 실험:
  - 200ms~350ms 지연 시 입력 처리 안정성
  - 재접속(Disconnect/Reconnect) 시 상태 복구
- 성공 기준:
  - 20회 연속 턴에서 상태 불일치 0건

## Phase 1: 코어 턴 시스템 (1~2주)
- 로비, 방 생성, 턴/주사위/이동/타일 이벤트
- 코인/스타 경제 시스템
- 서버 권한 검증 로직 구현

## Phase 2: 미니게임 프레임워크 (1~2주)
- 공통 인터페이스 + 결과 집계
- 샘플 미니게임 1종 구현
- 라운드 연동

## Phase 3: 콘텐츠 확장 (2~3주)
- 미니게임 2종 추가(총 3종)
- 맵 이벤트 다양화
- 밸런싱 지표 수집(획득 코인 분포, 승률 편차)

## Phase 4: 안정화/출시 준비 (1~2주)
- 이탈/재접속 처리 강화
- QA 자동화(시뮬레이션)
- 모니터링/로그 대시보드

---

## 9) 리스크와 롤백 전략

### 리스크 A: 네트워크 동기화 불안정
- 대응: authoritative 서버 고정 + 상태 버전 관리
- 롤백: 실시간 자유 이동 제거, 완전 턴락 방식으로 단순화

### 리스크 B: 미니게임 개발 비용 과다
- 대응: 공통 프레임워크 우선, 규칙 단순 미니게임부터 확장
- 롤백: 출시 시 미니게임 수를 3종으로 제한

### 리스크 C: 밸런스 붕괴(후반 눈덩이)
- 대응: 뒤처진 플레이어 보정 이벤트(약한 rubber banding)
- 롤백: 보정 강도 테이블 즉시 하향/비활성

---

## 10) 테스트 전략

### 자동 테스트
- 턴 상태 전이 테스트(FSM)
- 보드 경로 계산 테스트
- 경제 로직 테스트(코인/스타 변화)

### 시뮬레이션
- 봇 4인 1,000판 자동 플레이
- 지표: 평균 플레이 타임, 역전률, 승률 편차

### 수동 QA
- 재접속/지연/패킷 유실 시나리오 점검
- 라운드 전환 연출 및 UX 흐름 점검

---

## 11) 의사결정 로그 (초기)

1. MVP는 웹 기반으로 시작한다.
2. 서버 권한형 동기화 모델을 채택한다.
3. 미니게임은 플러그인 인터페이스로 표준화한다.
4. "콘텐츠 양"보다 "턴 루프 안정성"을 우선한다.

---

## 12) 바로 다음 액션

1. 기술 스택 최종 선택(웹/Unity 중 1안 확정)
2. 프로토타입 저장소 구조 생성
3. 로비 + 턴 FSM 최소 구현
4. 샘플 미니게임 1종 연결
5. 플레이 테스트로 재미/속도 지표 수집
